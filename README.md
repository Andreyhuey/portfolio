## Hello!

![](https://komarev.com/ghpvc/?username=Andreyhuey)

![](./src/assets/avatar.jpeg)

My name is Oluwadara Ola-Obaado a.k.a Andreyhuey

Upskilling As a Software Engineer

Favourite resources

- The pragmatic programmer your journey to mastery (1999)

Tips

### Chapter 1. A Pragmatic Philosophy

1. Care About your craft
2. Think! About your work
3. You have Agency
4. Provide Options, Don't make lame excuses
5. Don't live with broken windows
6. Be a catalyst for change
7. Remember the big picture
8. Make Quality a Requirements Issue
9. Invest Regularly in Your Knowledge Portfolio
10. Critically analyze what you read and hear
11. English is just another programming language
12. It's both what you say and the way you say it
13. Build Documentation In, Don't Bolt It On

### Chapter 2. A Pragmatic Approach

14. Good design is easier to change than bad design
15. DRY - Don't repeat yourself (it's is not a question of whether you'll remember but a question of when you'll forget)
16. Make it easy to reuse
17. Eliminate Effects Between Unrelated Things
18. There are no final decisions
19. Forgo Following Fads
20. Use Tracer Bullets to find the target
21. Prototype to learn
22. Program close to the problem domain
23. Estimate to avoid surprises
24. Iterate the schedule with the code

### Chapter 3. The Basic Tools

25. Keep Knowledge in plain text
26. Use the power of command shells
27. Achieve Editor Fluency
28. Always use version control
29. Fix the problem, not the blame
30. Don't panic
31. Failing Test Before Fixing Code
32. Read the damn error message
33. "select" isn't broken
34. Don't assume it-prove it
35. Learn a text manipulation language

### Chapter 4. Pragmatic Paranoia

36. You can't write perfect software
37. Design with contracts
38. Crash Early
39. Use Assertions to prevent the impossible
40. finish what you start
41. Act locally
42. Take small steps- always
43. avoid fortune-telling

### Chapter 5. Bend, or Break

44. Decoupled code is easier to change
45. Tell, Don't Ask
46. Don't Chain Method Calls
47. Avoid Global Data
48. If it's important enough to be global, wrap it in an API
49. programming is about code, but programs are about data.
50. don't hoard state; pass it around
51. don't Pay inheritance Tax
52. prefer interfaces to express polymorphism
53. delegate to services: has-a trumps is-a
54. use mixins to share functionality
55. Parameterize your app using external configuration

### Chapter 6. Concurrency

56. Analyze workflow to improve concurrency
57. shared state is incorrect state
58. random failures are often concurrency issues
59. use actors for concurrency without shared state
60. use blackboards to coordinate workflow

### chapter 7. While you are coding

61. Listen to your inner lizard
62. Don't Program by coincidence
63. Estimate the order of your algorithms
64. Test Your Estimates
65. Refactor early, refactor often
66. Testing is not about finding bugs
67. A test is the first user of your code
68. Build end-to-end, not top-down or bottom up
69. Design to test
70. Test your software, or your users will
71. Use property-base tests to validate your assumptions
72. Keep it simple and minimize attack surfaces
73. Apply Security patches quickly
74. Name well; rename when needed

### chapter 8. Before the project

75. No one knows exactly what they want
76. programmers help people understand what they want
77. Requirements are learned in a feedback loop
78. Work with a user to think like a user
79. Policy is Metadata
80. Use a project glossary
81. Don't Think Outside the box - find the box
82. Don't go into the code alone
83. Agile is not a noun; agile is how you do things

## Agile way of doing things

1. work out where you are
2. make the smallest meaningful step towards where you want to be.
3. Evaluate where you end up, and fix anything you broke.

### Resources

[Infinite scrolling carousel with hover effects using Framer Motion](https://www.youtube.com/watch?v=Ot4n)
